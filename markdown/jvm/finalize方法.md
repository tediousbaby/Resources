

##### 背景

大家都知道初始化的重要性，但是通常会忽略“清理”的重要性。如果程序中用到了“特殊的内存”，垃圾回收器是无法清理的。jvm为这种情况提供了**finalize()**方法来处理这种问题。

When the garbage collector is ready to release the storage used for your object, it will first call finalize(), and only on the next garbage-collection pass will it reclaim the object’s memory. 


##### 误解

finalize()不能当做析构函数；因为C++中的析构函数在对象不使用的时候必须被调用，而finalize()方法只有在垃圾清理之前被调用，应用程序是否会执行垃圾清理，是无法预知的。

如果当一个对象不需要再使用时需要执行一个任务的话，我们必须手动调用这个任务，而不能依赖于finalize()的执行，因为finalize()方法可能不会被调用。


##### 什么时候要用？

对象重写finalize()方法主要用来为了在被垃圾回收之前，用来清理占用的其他系统资源。因为GC只会清理java对象占用的内存空间，而不会涉及其他类型的资源「避免内存泄露」。比如你调用了C语言，使用了malloc()开辟了一段内存空间。在java对象被收集的时候，虚拟机只能释放java对象占用的空间，而不能释放C开辟的内存空间，所你你在释放此对象之前要先回收你在C语言中开辟的空间。

##### 什么时候被执行?

对象被回收时，要经过两次标记，第一次标记，如果finalize被重写，或者finalize被调用过，那么垃圾回收并不会去执行finalize，第二次标记，如果对象不能在finalize中成功拯救自己，那真的就要被回收了


被标记为要清除的对象后，会进行筛选，如果这个对象没被调用过finalize方法并且重写了finalize方法，，那么就会把这个对象加入一个叫F-queue的队列中，然后虚拟机会启动一个优先级较低的finalizer线程去执行这个对象的finalize方法，如果在这些方法结束之前这个对象又有了一个引用链到达gc root 那么 这个对象这次就是自救成功了， 垃圾收集器不会收集它，当然同一个对象实例的finalize方法只会被调用一次，也就是说只有一次自救机会。


一个重写了finalize方法的对象如果想要被回收掉，需要经历两个单独的垃圾收集周期。在第一个周期中，某个对象被标记为可回收，进而才能进行析构。但是因为在析构过程中仍有微弱的可能这个对象会重新复活。这种情况下，在这个对象真实销毁之前，垃圾回收器需要再次运行。因为析构可能并不是很及时，所以在调用对象的析构之前，需要经历数量不确定的垃圾收集周期。这就意味着在真正清理掉这个对象的时候可能发生很大的延迟。